# Type Soundness for DOT via logical relations

## File Layout

Code is not perfectly modularized, but here is a rough layout of the various files.

* Syntax:
  - dotsyn_orig.v: Autosubst2-generated DOT SYNtax
  - dotsyn.v: DOT SYNtax, based on dotsyn_orig.v
  - Autosubst2.v: Autosubst2 library
  - axioms.v: axioms for propositional and functional extensionality, as used for Autosubst2.
* Operational semantics
  - synFuncs.v (SYNtactic Functions): utility functions to manipulate syntax (field lookup)
  - operational.v: instantiate Iris with DOT operational semantics
  - synLemmas.v: (SYNtactic Lemmas): lemmas about synFuncs.v
  - rules.v: lemmas about WP and this language's semantics.
* Translation from syntactic values/terms/... to semantic ones:
  - synToSem.v
* Unary logical relation:
  - unary_lr.v
* (Sub)typing lemmas about unary logical relation:
  - lr_lemmasDefs.v: lemmas about DEFinition typing
  - lr_lemmasTSel.v: lemmas about TSel (type selection)
  - lr_lemma.v: other misc typing lemmas
  - experiments.v: experiments on typing lemmas that don't make sense
* Support
  - tactics.v: misc homegrown Ltac automation

### Whence dotsyn.v

That comes from the `dotsyn_orig.v`, autogenerated from `dotsyn.lf`, with lemmas
filled in following the Autosubst2 case study.

Usually one needs to fill in only the proofs, not the statements, with a couple
of exceptions.

### Generating `dotsyn_orig.v`

To regenerate `dotsyn_orig.v` as needed, checkout and install
https://github.com/Blaisorblade/autosubst2-proto, branch experiments,
via stack (or cabal), and run

```
as2-exe -i dotsyn.lf -o dotsyn_orig.v
```

To also produce a graph showing dependencies among datatypes (just useful for debugging Autosubst2 and checking it understands your signature correctly), use:

```
as2-exe -i dotsyn.lf -d dotsyn.dot -o dotsyn_orig.v && dot -Tpdf dotsyn.dot -o dotsyn.pdf
```

## Installation
### Iris version

Install Iris commit 19e8581017fd4d5118a3cb5afc066a55992ecc57, for instance via
`opam install coq-iris.dev.2018-11-01.2.19e85810`.

### To use glorious opam 2.0

One can use opam 2.0 to create a local switch, that is, a local version of iris
and of coq that will only be used when one is inside this directory. _The first
time,_ one should do:

```shell
opam repo add iris-dev https://gitlab.mpi-sws.org/FP/opam-dev.git --set-default --all
```

to add the iris opam repository, and then, in this directory, do

```shell
opam switch create . --locked
```

to create the local switch. Then, every time you wants to work on this, do

```shell
eval $(opam env)
```

so that `coqc`, etc, correspond to the local version. You can also configure
opam to do this automatically by answering yes when `opam init` asks you the
following:
"A hook can be added to opam's init scripts to ensure that the shell remains in sync with the opam environment when they are loaded. Set that up?"

To answer that question again, check `opam init` docs; `opam init --reinit`
works here.

### Upgrading switch

Use

```
opam install .
```

to upgrade the switch when we bump dependencies (which for now we do seldom).
To make this succeed, you might need to first run `opam unpin coq-stdpp
coq-iris`, `opam uninstall dot-iris`, `opam uninstall .`, or such.

After updating deps, you will need to do a clean build, so `make clean` and then
`make`.

### Bumping Iris

Find the version name on top of
https://gitlab.mpi-sws.org/iris/opam/commits/master/packages/coq-iris, then
modify `opam`, *commit*, and reinstall with `opam install .`
